---
layout: post
title: "선택정렬(Selection Sort) 알고리즘"
subtitle: "Algorithm"
date: 2019-12-21 14:12:42
author: kwon
categories: algorithm
---
이제 종강도 했으니 알고리즘 공부를 다시 시작해보려 한다. 유튜버 나동빈님의 강의를 보면서 하나씩 천천히 정리해 나가도록 해보자. 일반적으로 알고리즘을 공부할 때 가장 먼저 풀어보는 문제는 정렬 문제인데, 왜냐면 정렬만큼 알고리즘의 효율성 차이를 극명하게 보여주기 때문이라고 한다. 그래서 여러가지의 정렬 알고리즘을 먼저 배우고 알고리즘의 시간 복잡도에 대해 단계적으로 이해해 보자.

## 선택 정렬(Selection Sort)
> ### 선택 정렬
> 선택 정렬은 제자리 정렬 알고리즘의 하나로, 다음와 같은 순서로 이루어진다.
> 1. 주어진 리스트 중에 최소값을 찾는다
> 2. 그 값을 맨 앞에 위치한 값과 교체한다.(패스)
> 3. 맨 처음 위치를 뺀 나머지 리스트를 같은 방법으로 교체한다.
>
>출처 - 위키백과

위의 설명처럼 선택 정렬은 가장 작은 것을 선택해서 제일 앞으로 보내는 알고리즘이다. 예를 들어, 3 1 2 5 4 라는 순서의 숫자들을 오름차순으로 정렬한다고 생각해보자. 먼저 리스트의 최솟값을 구하여 가장 앞의 숫자와 위치를 바꾸게 되면 1이 최솟값이므로 3과 자리를 바꾸어 1 3 2 5 4 가 된다. 다음 1을 뺀 나머지의 리스트의 최솟값은 2 이므로 3과 자리를 바꾸어 1 2 3 5 4가 되고, 다음은 3이 최솟값이므로 넘어가서 같은 과정을 반복하면 1 2 3 4 5 로 오름차순 정렬이 끝나게 된다.

```C++
#include<iostream>

using namespace std;

int main()
{
	int i, j, min, index, temp; // min : 최솟값, index : 최솟값의 인덱스
	int array[10] = { 1, 10, 5, 8, 7, 6, 4, 3, 2, 9 };

	for (i = 0; i < 10; i++)
	{
		min = 9999;
		for (j = i; j < 10; j++)
		{
			if (array[j] < min) // 최솟값을 구함
			{
				min = array[j];
				index = j;
			}
		}
		temp = array[i]; // 최솟값과 자리 바꾸기
		array[i] = min;
		array[index] = temp;


		for (j = 0; j < 10; j++)
		{
			cout << array[j] << " ";
		}
		cout << "\n";
	}


	cout << "결과 :";
	for (i = 0; i < 10; i++)
	{
		cout << array[i] << " ";
	}

	return 0;

}
```

위와 같이 선택정렬을 작성할 수 있다. 또한 아래와 같이 정렬이 진행되는 과정을 확인할 수 있다. 선택 정렬은 앞쪽부터 정렬이 수행되는 것을 확인할 수 있다.

<div style="width: 250px; height: 200px;">
    <img src="https://kyu9341.github.io/assets/selectionsort.png" style="width: 250px
    ; height: 200px;">
</div>


이제 선택 정렬을 수행하는데에 얼마만큼의 시간이 걸리는지를 시간복잡도로 표현할 수 있는데 계산 방법은 다음과 같다.

 1 2 3 4 5 6 7 8 9 10 의 10개의 수를 정렬한다고 생각하면

 10 + 9 + 8 + ... + 1 의 수 만큼 비교연산을 수행해야 한다. 즉, 10 * (10 + 1) / 2 = 55

 이것을 등차수열의 식에 의해 표현하면 **N * (N + 1) / 2** 로 표현할 수 있다. 즉, 이 알고리즘의 수행시간을 앞의 수식처럼 표현할 수가 있다는 것이다. 이때 일반적으로 컴퓨터에서는 2로 나눈다거나 1을 더한다거나 하는 것은 N이 매우 커지는 경우에는 무시할 수 있기 때문에 간단하게 더하거나 나누거나 하는 연산들은 모두 무시를 하게 된다.(가장 큰 차수만 보고 판단) 따라서 위의 수식이 **N * N** 으로 표현 할 수 가있다는 것이다.

 이것을 O(N * N) => O(N^2)이라고 표시할 수 있는데 이와 같은 표기법은 특정한 알고리즘의 수행시간을 간략하게 표현하는 방법이며 O(Big-O) 표기법이라 한다.

일반적으로 정렬 알고리즘에서 N^2의 복잡도는 아주 비효율적이고 느린 속도라고 할 수 있다.

참조 : <https://blog.naver.com/ndb796/221226800661>

<https://ko.wikipedia.org/wiki/%EC%84%A0%ED%83%9D_%EC%A0%95%EB%A0%AC>
