---
layout: post
title: "병합 정렬(Merge Sort) 알고리즘"
subtitle: "Algorithm"
date: 2019-12-22 11:44:19
author: kwon
categories: algorithm
---
이번 포스팅에서는 **병합 정렬(Merge Sort)** 에 대해 알아보겠다. 병합 정렬도 퀵 정렬과 마찬가지로 '분할 정복'방법을 채택한 알고르즘이며 결과적으로 퀵 정렬과 동일하게 O(N*logN)의 시간복잡도를 가진다.

퀵 정렬은 피벗 값에 따라서 편향되게 분할할 가능성이 있다는 점에서 최악의 경우 O(N^2)의 시간 복잡도를 가지지만 병합 정렬은 정확히 반절씩 나눈다는 점에서 최악의 경우에도 O(N*logN)을 보장한다.


## 병합 정렬(Merge Sort)
>합병 정렬 또는 병합 정렬(merge sort)은 O(n log n) 비교 기반 정렬 알고리즘이다. 일반적인 방법으로 구현했을 때 이 정렬은 안정 정렬에 속하며, 분할 정복 알고리즘의 하나이다. 존 폰 노이만이 1945년에 개발했다. 하향식 합병 정렬에 대한 자세한 설명과 분석은 1948년 초 헤르만 골드스타인과 폰 노이만의 보고서에 등장하였다.
>합병 정렬은 다음과 같이 작동한다.
>
>1. 리스트의 길이가 1 이하이면 이미 정렬된 것으로 본다. 그렇지 않은 경우에는
>2. 분할(divide) : 정렬되지 않은 리스트를 절반으로 잘라 비슷한 크기의 두 부분 리스트로 나눈다.
>3. 정복(conquer) : 각 부분 리스트를 재귀적으로 합병 정렬을 이용해 정렬한다.
>4. 결합(combine) : 두 부분 리스트를 다시 하나의 정렬된 리스트로 합병한다. 이때 정렬 결과가 임시배열에 저장된다.
>5. 복사(copy) : 임시 배열에 저장된 결과를 원래 배열에 복사한다.
>
>출처 - 위키백과

병합 정렬은 하나의 큰 문제를 두 개의 작은 문제로 분할한 뒤에 각자계산하고 나중에 합치는 방법을 채택한다.

다음의 예를 보자.

7 6 5 8 3 5 9 1 의 배열이 있다고 생각해보자.

먼저 배열을 분할하여 크기가 1인 배열 상태로 시작한다.

| 7 | 6 | 5 | 8 | 3 | 5 | 9 | 1 |

여기서 1단계로 배열의 크기를 2로 만들어 합쳐주며 정렬을 수행한다. 크기가 1이었던 배열을 두 개씩 묶어서 합친 것이다.

| 6 7 | 5 8 | 3 5 | 1 9 |

위와 같이 크기가 2인 배열로 병합하며 정렬을 수행한다. 이제 크기가 2인 배열을 두 개씩 묶어 크기가 4인 배열을 만들어보겠다. 이때도 마찬가지로 정렬을 하며 진행된다.

| 5 6 7 8 | 1 3 5 9 |

이제 크기가 4인 배열로 병합되었으므로 다시 두 개를 묶어 크기가 8인 배열로 만들며 정렬을 수행한다.

| 1 3 5 5 6 7 8 9 |

여기까지 되었다면 정렬이 완료된다.

지금의 예제는 크기가 8인 배열이었으므로 3단계에 걸쳐 진행이 되었다. 즉, log(2)8 = 3 이기 때문에 3단계가 필요했던 것이다. 만약 크기가 N인 배열이라면 logN 만큼의 단계가 필요할 것이다.

크기가 N 이고 logN 만큼의 단계가 필요하므로 여기서 시간복잡도는 O(N*logN)이 되는 것이다.

이제 배열이 합쳐지면서 정렬이 되는 과정을 한 번 살펴보자.

| 7 \| 6 \| 5 \| 8 \| 3 \| 5 \| 9 \| 1 |

처음 크기가 2인 배열로 합쳐줄 때는 간단히 묶이는 두 수를 비교하여 작은 것을 앞에, 큰 것을 뒤에 두면 된다.

| 6 7 \| 5 8 \| 3 5 \| 1 9 |

다음으로 2인 배열이 4가 되며 정렬되는 과정을 보자. 먼저 앞의 두 배열부터 비교해보면

| **6** 7 | **5** 8 | 여기서 먼저 각 배열에서 가장 작은 수 끼리 비교를 한다. 이전 단계에서 정렬이 되어서 내려왔으므로 왼쪽의 수들만 먼저 비교하면 된다.

6과 5를 비교하여 더 작은 수를 새로운 배열의 첫 번째 인덱스에 넣어준다.

| 5 - - - |

그럼 새로운 배열은 위와 같은 상태일 것이고 이전의 배열은 다음과 같은 상태일 것이다.

| **6** 7 \| - **8** |

이제 다시 앞의 배열의 가장 작은 수인 6과 뒤의 배열의 가장 작은 수 인 8을 비교하여 더 작은 6을 새로운 배열의 두번째 인덱스에 넣어주겠다.

| 5 6 - - |

새로운 배열에 6이 추가되었고 이전 배열은 7과 8이 남았으므로 다시 비교를 하여 반복한다.

| - **7** \| - **8** |

| 5 6 7 - |

| - - \| - **8** |

| 5 6 7 8 |

위와 같은 과정으로 배열이 합쳐지면서 정렬이 수행된다. 이 때 배열의 크기가 4였으므로 4번의 비교 연산만으로 정렬이 수행된 것을 볼 수 있다. 즉, 배열의 크기가 N이라면 N번의 비교 연산만 거치면 정렬을 수행할 수 있다는 것이다.







```C++


```


참조 : <https://blog.naver.com/ndb796/221242106787>

<https://ko.wikipedia.org/wiki/%ED%95%A9%EB%B3%91_%EC%A0%95%EB%A0%AC>
