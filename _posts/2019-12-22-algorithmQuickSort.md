---
layout: post
title: "퀵 정렬(Quick Sort) 알고리즘"
subtitle: "Algorithm"
date: 2019-12-22 11:44:19
author: kwon
categories: algorithm
---
이제까지 공부했던 정렬 알고리즘은 모두 시간복잡도 O(N^2)를 가지는 알고리즘이었다. 이러한 시간복잡도를 가지는 알고리즘은 사실상 데이터의 갯수가 커지면 일반적인 상황에서 사용하기가 매우 어렵다.  그렇기 때문에 더욱 빠른 알고리즘이 필요한데 그 대표적인 빠른 알고리즘이 **퀵 정렬** 알고리즘이다.

## 퀵 정렬(Quick Sort)
>퀵 정렬은 분할 정복(divide and conquer) 방법을 통해 리스트를 정렬한다.
>
>1. 리스트 가운데서 하나의 원소를 고른다. 이렇게 고른 원소를 피벗이라고 한다.
>
>2. 피벗 앞에는 피벗보다 값이 작은 모든 원소들이 오고, 피벗 뒤에는 피벗보다 값이 큰 모든 원소들이 오도록 피벗을 기준으로 리스트를 둘로 나눈다. 이렇게 리스트를 둘로 나누는 것을 분할이라고 한다. 분할을 마친 뒤에 피벗은 더 이상 움직이지 않는다.
>
>3. 분할된 두 개의 작은 리스트에 대해 재귀(Recursion)적으로 이 과정을 반복한다. 재귀는 리스트의 크기가 0이나 1이 될 때까지 반복된다.
>
>재귀 호출이 한번 진행될 때마다 최소한 하나의 원소는 최종적으로 위치가 정해지므로, 이 알고리즘은 반드시 끝난다는 것을 보장할 수 있다.
>
>출처 - 위키백과

퀵 정렬은 대표적인 '분할 정복' 알고리즘으로 평균 속도가 O(N*logN)이다. 이때 logN은 사실상 거의 상수라고 해도 무방할 만큼 작은 수이다.

예를 들어, 2^10 이 약 1,000 이고 2^20이 약 1,000,000 이므로 N이 1,000,000이라 하더라도 $log~2~N = 20$ 밖에 되지 않는다. 즉, 굉장히 빠르다는 것을 알 수 있다.


```C++


```

<div style="width: 250px; height: 200px;">
    <img src="https://kyu9341.github.io/assets/quicksort.png" style="width: 250px
    ; height: 200px;">
</div>



참조 : <https://blog.naver.com/ndb796/221226813382>

<https://ko.wikipedia.org/wiki/%ED%80%B5_%EC%A0%95%EB%A0%AC>
